use std::{
    borrow::Cow,
    collections::{hash_map::Entry, HashMap, HashSet, VecDeque},
    num::NonZeroUsize,
    task::{Context, Poll},
};

use crate::error::{CommandExecutionError, P2PError};
use futures::future::BoxFuture;
use libp2p::{
    core::{connection::ConnectionId, transport::ListenerId, ConnectedPoint},
    identity::Keypair,
    kad::{
        record::Key, store::MemoryStore, AddProviderOk, GetClosestPeersError, Kademlia,
        KademliaConfig, KademliaEvent, QueryId, QueryResult, Quorum,
    },
    mdns::{MdnsEvent, TokioMdns as Mdns},
    swarm::{
        ConnectionHandler, DialError, IntoConnectionHandler, NetworkBehaviour,
        NetworkBehaviourAction, PollParameters,
    },
    Multiaddr, PeerId,
};
use tokio::sync::oneshot;
use tracing::{debug, error, info, instrument, trace, warn};

type PendingDials = HashMap<PeerId, oneshot::Sender<Result<(), P2PError>>>;
type PendingRecordRequest = oneshot::Sender<Result<Vec<Multiaddr>, CommandExecutionError>>;

/// DiscoveryBehaviour is responsible to discover and manage connections with peers
pub(crate) struct DiscoveryBehaviour {
    /// Kademlia requests and answers.
    pub kademlia: Kademlia<MemoryStore>,

    /// Contains current listenerId of the swarm
    pub active_listeners: HashSet<ListenerId>,

    /// Events to dispatch in the stream
    events: VecDeque<DiscoveryOut>,

    /// Internal behaviour commands to execute
    inner_commands: VecDeque<
        NetworkBehaviourAction<DiscoveryOut, <Self as NetworkBehaviour>::ConnectionHandler>,
    >,

    /// User-defined list of nodes and their addresses.
    #[allow(dead_code)]
    permanent_addresses: Vec<(PeerId, Multiaddr)>,

    /// Same as `permanent_addresses`, except that addresses that fail to reach a peer are
    /// removed.
    #[allow(dead_code)]
    ephemeral_addresses: HashMap<PeerId, Vec<Multiaddr>>,

    /// Identity of our local node.
    #[allow(dead_code)]
    local_peer_id: PeerId,

    /// Number of nodes we're currently connected to.
    #[allow(dead_code)]
    num_connections: u64,

    /// Holds the pending dials and their sender
    pending_dial: PendingDials,

    /// Contains peer ids of dialled node
    pub peers: HashSet<PeerId>,

    /// Pending DHT queries
    pending_record_requests: HashMap<QueryId, PendingRecordRequest>,
}

/// [`Mdns::new`] returns a future. Instead of forcing [`DiscoveryConfig::finish`] and all its
/// callers to be async, lazily instantiate [`Mdns`].
#[allow(dead_code)]
pub enum MdnsWrapper {
    Instantiating(BoxFuture<'static, std::io::Result<Mdns>>),
    Ready(Box<Mdns>),
    Disabled,
}

impl MdnsWrapper {
    #[allow(dead_code)]
    fn addresses_of_peer(&mut self, peer_id: &PeerId) -> Vec<Multiaddr> {
        match self {
            Self::Instantiating(_) => Vec::new(),
            Self::Ready(mdns) => mdns.addresses_of_peer(peer_id),
            Self::Disabled => Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn poll(
        &mut self,
        cx: &mut Context<'_>,
        params: &mut impl PollParameters,
    ) -> Poll<NetworkBehaviourAction<MdnsEvent, <Mdns as NetworkBehaviour>::ConnectionHandler>>
    {
        loop {
            match self {
                Self::Instantiating(fut) => {
                    *self = match futures::ready!(fut.as_mut().poll(cx)) {
                        Ok(mdns) => Self::Ready(Box::new(mdns)),
                        Err(err) => {
                            warn!("Failed to initialize mDNS: {:?}", err);
                            Self::Disabled
                        }
                    }
                }
                Self::Ready(mdns) => return mdns.poll(cx, params),
                Self::Disabled => return Poll::Pending,
            }
        }
    }
}

/// Event generated by the `DiscoveryBehaviour`.
#[derive(Debug)]
pub enum DiscoveryOut {
    UnroutablePeer(PeerId),
    SelfDiscovered(PeerId, Multiaddr),
    Discovered(PeerId),
    BootstrapOk,
}

impl NetworkBehaviour for DiscoveryBehaviour {
    type ConnectionHandler = <Kademlia<MemoryStore> as NetworkBehaviour>::ConnectionHandler;
    type OutEvent = DiscoveryOut;

    fn new_handler(&mut self) -> Self::ConnectionHandler {
        self.kademlia.new_handler()
    }

    fn addresses_of_peer(&mut self, peer_id: &PeerId) -> Vec<Multiaddr> {
        trace!("addresses_of_peer");
        self.kademlia.addresses_of_peer(peer_id)
    }

    fn inject_connection_established(
        &mut self,
        peer_id: &PeerId,
        connection_id: &ConnectionId,
        endpoint: &ConnectedPoint,
        failed_addresses: Option<&Vec<Multiaddr>>,
        other_established: usize,
    ) {
        debug!("Connection established with peer: {peer_id}");
        if let Some(sender) = self.pending_dial.remove(peer_id) {
            self.peers.insert(*peer_id);
            if sender.send(Ok(())).is_err() {
                warn!(
                    %peer_id,
                    "Could not notify successful dial with {peer_id}: initiator dropped"
                );
            }
        }

        self.kademlia.inject_connection_established(
            peer_id,
            connection_id,
            endpoint,
            failed_addresses,
            other_established,
        );
    }

    fn inject_connection_closed(
        &mut self,
        peer_id: &PeerId,
        connection_id: &ConnectionId,
        connected_point: &ConnectedPoint,
        handler: <Self::ConnectionHandler as IntoConnectionHandler>::Handler,
        remaining_established: usize,
    ) {
        self.kademlia.inject_connection_closed(
            peer_id,
            connection_id,
            connected_point,
            handler,
            remaining_established,
        );
    }

    fn inject_address_change(
        &mut self,
        peer_id: &PeerId,
        conn: &ConnectionId,
        old: &ConnectedPoint,
        new: &ConnectedPoint,
    ) {
        self.kademlia.inject_address_change(peer_id, conn, old, new);
    }

    fn inject_event(
        &mut self,
        peer_id: PeerId,
        connection: ConnectionId,
        event: <<Self::ConnectionHandler as IntoConnectionHandler>::Handler as ConnectionHandler>::OutEvent,
    ) {
        trace!("inject event: {event:?}");
        self.kademlia.inject_event(peer_id, connection, event);
    }

    fn inject_dial_failure(
        &mut self,
        peer_id: Option<PeerId>,
        handler: Self::ConnectionHandler,
        error: &DialError,
    ) {
        error!("Dial failure: {error:?}");
        if let Some(peer_id) = peer_id {
            if let Some(sender) = self.pending_dial.remove(&peer_id) {
                if sender.send(Err(crate::error::P2PError::DialError)).is_err() {
                    warn!("Could not notify dial failure because initiator is dropped");
                }
            }
        }

        self.kademlia.inject_dial_failure(peer_id, handler, error);
    }

    fn inject_listen_failure(
        &mut self,
        local_addr: &Multiaddr,
        send_back_addr: &Multiaddr,
        handler: Self::ConnectionHandler,
    ) {
        trace!("inject_listen_failure");
        self.kademlia
            .inject_listen_failure(local_addr, send_back_addr, handler);
    }

    fn inject_new_listener(&mut self, id: ListenerId) {
        self.active_listeners.insert(id);
        self.kademlia.inject_new_listener(id);
    }

    fn inject_new_listen_addr(&mut self, id: ListenerId, addr: &Multiaddr) {
        self.kademlia.inject_new_listen_addr(id, addr);
    }

    fn inject_expired_listen_addr(&mut self, id: ListenerId, addr: &Multiaddr) {
        trace!("inject_expired_listen_addr");
        self.kademlia.inject_expired_listen_addr(id, addr);
    }

    fn inject_listener_error(&mut self, id: ListenerId, err: &(dyn std::error::Error + 'static)) {
        trace!("inject_listener_error");
        self.kademlia.inject_listener_error(id, err);
    }

    fn inject_listener_closed(&mut self, id: ListenerId, reason: Result<(), &std::io::Error>) {
        trace!("inject_listener_closed");
        self.kademlia.inject_listener_closed(id, reason);
    }

    fn inject_new_external_addr(&mut self, addr: &Multiaddr) {
        trace!("inject_new_external_addr");
        self.kademlia.inject_new_external_addr(addr);
    }

    fn inject_expired_external_addr(&mut self, addr: &Multiaddr) {
        trace!("inject_expired_listen_addr");
        self.kademlia.inject_expired_external_addr(addr);
    }

    #[instrument(name = "DiscoveryBehaviour::poll", skip_all, fields(peer_id = %self.local_peer_id))]
    fn poll(
        &mut self,
        cx: &mut Context<'_>,
        params: &mut impl PollParameters,
    ) -> Poll<NetworkBehaviourAction<Self::OutEvent, Self::ConnectionHandler>> {
        if let Some(action) = self.inner_commands.pop_front() {
            return Poll::Ready(action);
        }

        if let Some(event) = self.events.pop_front() {
            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(event));
        }

        while let Poll::Ready(action) = self.kademlia.poll(cx, params) {
            match action {
                NetworkBehaviourAction::GenerateEvent(event) => {
                    match event {
                        KademliaEvent::RoutingUpdated {
                            peer,
                            is_new_peer: true,
                            ..
                        } => {
                            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(
                                DiscoveryOut::Discovered(peer),
                            ));
                        }
                        KademliaEvent::RoutablePeer { peer, address } => {
                            debug!("RoutablePeer {:?} {:?}", peer, address);
                            // return Poll::Ready(NetworkBehaviourAction::GenerateEvent(
                            //     DiscoveryOut::Discovered(peer),
                            // ))
                        }
                        KademliaEvent::UnroutablePeer { peer } => {
                            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(
                                DiscoveryOut::UnroutablePeer(peer),
                            ))
                        }
                        KademliaEvent::OutboundQueryCompleted {
                            result: QueryResult::StartProviding(res),
                            ..
                        } => match res {
                            Ok(AddProviderOk { key }) => {
                                debug!("Discovery => Start providing {key:?}");
                            }
                            Err(error) => error!("Discovery => Start providing error {error:?}"),
                        },

                        KademliaEvent::OutboundQueryCompleted {
                            result: QueryResult::RepublishProvider(res),
                            ..
                        } => match res {
                            Ok(ok) => debug!("Discovery => Provider republished: {:?}", ok.key,),
                            Err(e) => debug!(
                                "Discovery => Republishing provider {:?} failed with: {:?}",
                                e.key(),
                                e,
                            ),
                        },

                        KademliaEvent::OutboundQueryCompleted {
                            result: QueryResult::GetClosestPeers(res),
                            ..
                        } => match res {
                            Err(GetClosestPeersError::Timeout { key, peers }) => {
                                debug!(
                                    "Discovery => Query for {:?} timed out with {} results",
                                    // TODO: Encode this?
                                    &key,
                                    peers.len(),
                                );
                            }
                            Ok(ok) => {
                                debug!(
                                    "Discovery => Query for {:?} yielded {:?} results",
                                    &ok.key,
                                    ok.peers.len(),
                                );
                                if ok.peers.is_empty() && self.num_connections != 0 {
                                    debug!(
                                        "Discovery => Random Kademlia query has yielded empty results",
                                    );
                                }
                            }
                        },

                        KademliaEvent::OutboundQueryCompleted {
                            result: QueryResult::Bootstrap(res),
                            ..
                        } => match res {
                            Ok(_) => {
                                return Poll::Ready(NetworkBehaviourAction::GenerateEvent(
                                    DiscoveryOut::BootstrapOk,
                                ));
                            }
                            Err(e) => error!("Error: bootstrap : {e:?}"),
                        },

                        KademliaEvent::OutboundQueryCompleted {
                            result: QueryResult::PutRecord(res),
                            ..
                        } => {
                            if let Err(e) = res {
                                error!("{e:?}");
                            }
                        }

                        KademliaEvent::OutboundQueryCompleted {
                            result: QueryResult::GetRecord(res),
                            id,
                            ..
                        } => match res {
                            Ok(result) => {
                                if let Some(sender) = self.pending_record_requests.remove(&id) {
                                    if let Some(peer_record) = result.records.first() {
                                        if let Ok(addr) =
                                            Multiaddr::try_from(peer_record.record.value.clone())
                                        {
                                            if let Some(peer_id) = peer_record.record.publisher {
                                                if !sender.is_closed() {
                                                    self.kademlia
                                                        .add_address(&peer_id, addr.clone());

                                                    if sender.send(Ok(vec![addr.clone()])).is_err()
                                                    {
                                                        // TODO: Hash the QueryId
                                                        warn!("Could not notify Record query ({id:?}) response because initiator is dropped");
                                                    }
                                                }

                                                return Poll::Ready(
                                                    NetworkBehaviourAction::GenerateEvent(
                                                        DiscoveryOut::SelfDiscovered(peer_id, addr),
                                                    ),
                                                );
                                            }
                                        }
                                    }
                                }
                            }

                            Err(error) => error!("{error:?}"),
                        },

                        // We never start any other type of query.
                        KademliaEvent::OutboundQueryCompleted { result: e, .. } => {
                            warn!("Discovery => Unhandled Kademlia event: {:?}", e)
                        }

                        KademliaEvent::RoutingUpdated {
                            peer,
                            is_new_peer,
                            addresses,
                            bucket_range,
                            old_peer,
                        } => {
                            debug!(
                                "RoutingUpdated, {:?}, {:?}, {:?}, {:?}, {:?}",
                                peer, is_new_peer, addresses, bucket_range, old_peer
                            );
                        }
                        KademliaEvent::PendingRoutablePeer { .. } => debug!("PendingRoutablePeer"),
                        KademliaEvent::InboundRequest { request } => {
                            debug!("InboundRequest, {:?}", request);
                        }
                    }
                }

                NetworkBehaviourAction::Dial { opts, handler } => {
                    debug!("Discovery => Dial {opts:?}");
                    return Poll::Ready(NetworkBehaviourAction::Dial { opts, handler });
                }

                NetworkBehaviourAction::NotifyHandler {
                    peer_id,
                    handler,
                    event,
                } => {
                    return Poll::Ready(NetworkBehaviourAction::NotifyHandler {
                        peer_id,
                        handler,
                        event,
                    });
                }

                NetworkBehaviourAction::ReportObservedAddr { .. } => todo!(),
                NetworkBehaviourAction::CloseConnection { .. } => todo!(),
            }
        }

        Poll::Pending
    }
}

impl DiscoveryBehaviour {
    #[instrument(name = "DiscoveryBehaviour", skip_all, fields(peer_id = %peer_key.public().to_peer_id()))]
    pub fn new(
        peer_key: Keypair,
        discovery_protocol: Cow<'static, [u8]>,
        known_peers: &[(PeerId, Multiaddr)],
        _with_mdns: bool,
    ) -> Self {
        let local_peer_id = peer_key.public().to_peer_id();
        let kademlia_config = KademliaConfig::default()
            .set_protocol_names(vec![discovery_protocol])
            .set_replication_factor(NonZeroUsize::new(1).unwrap())
            // .set_replication_interval(Some(Duration::from_secs(30)))
            // .set_publication_interval(Some(Duration::from_secs(30)))
            // .set_provider_publication_interval(Some(Duration::from_secs(30)))
            .to_owned();

        let mut kademlia = Kademlia::with_config(
            local_peer_id,
            MemoryStore::new(local_peer_id),
            kademlia_config,
        );

        for known_peer in known_peers {
            info!(
                "Kademlia:  ---- adding peer:{} at {}",
                &known_peer.0, &known_peer.1
            );
            kademlia.add_address(&known_peer.0, known_peer.1.clone());
        }

        if let Err(store_error) = kademlia.start_providing("topos-tce".as_bytes().to_vec().into()) {
            warn!(reason = %store_error, "Could not start providing Kademlia protocol `topos-tce`")
        }

        if kademlia.bootstrap().is_err() {
            warn!("Bootstrapping failed because of NoKnownPeers, ignore this warning if boot-node");
        }

        Self {
            kademlia,
            active_listeners: HashSet::new(),
            events: VecDeque::new(),
            inner_commands: VecDeque::new(),
            local_peer_id,
            permanent_addresses: known_peers.iter().map(|(p, a)| (*p, a.clone())).collect(),
            ephemeral_addresses: HashMap::new(),
            num_connections: 0,
            pending_dial: HashMap::new(),
            peers: HashSet::new(),
            pending_record_requests: HashMap::new(),
        }
    }

    pub fn dial(
        &mut self,
        peer_id: PeerId,
        peer_addr: Multiaddr,
        sender: oneshot::Sender<Result<(), P2PError>>,
    ) {
        info!("Sending an active Dial");
        let handler = self.new_handler();
        match (self.peers.get(&peer_id), self.pending_dial.entry(peer_id)) {
            (None, Entry::Vacant(entry)) => {
                self.inner_commands.push_back(NetworkBehaviourAction::Dial {
                    opts: peer_addr.into(),
                    handler,
                });
                entry.insert(sender);
            }

            _ => {
                if sender.send(Err(P2PError::AlreadyDialed(peer_id))).is_err() {
                    warn!("Could not notify that {peer_id} was already dialed because initiator is dropped");
                }
            }
        }
    }

    pub fn get_record(
        &mut self,
        key: Key,
        sender: oneshot::Sender<Result<Vec<Multiaddr>, CommandExecutionError>>,
    ) {
        let query_id = self.kademlia.get_record(key, Quorum::One);

        self.pending_record_requests.insert(query_id, sender);
    }
}
